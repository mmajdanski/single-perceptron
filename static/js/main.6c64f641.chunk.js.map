{"version":3,"sources":["ml.js","App.js","serviceWorker.js","index.js"],"names":["genData","dataPoints","x","Math","random","y","bias","labelData","map","data","Object","objectSpread","label","weightData","weight","bias_weight","guessData","weightedSum","guess","sign","trainedData","learningRate","error","newWeight","deltaWeight","newBiasWeight","meanSquareError","pow","CIRCLE_SIZE","LEARNING_RATE","ITERATIONS","TIMEOUT_BETWEEN_ITERATIONS","App","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","drawKnownData","index","react_default","a","createElement","key","cx","cy","r","fill","drawGuessData","startTraining","Promise","resolve","setTimeout","ml","state","newTrainedData","setState","meanSquaredError","mse","componentDidMount","labeledData","weightedData","asyncToGenerator","regenerator_default","mark","_callee","wrap","_context","prev","next","iteration","stop","className","width","height","fillOpacity","x1","x2","y1","y2","stroke","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6c64f641.chunk.js","sourcesContent":["const CANVAS_SIZE = 600;\r\nconst NUM_DATA_POINTS = 150;\r\n\r\nexport const genData = () => {\r\n  let dataPoints = [];\r\n  for (let x = 0; x < NUM_DATA_POINTS; x++) {\r\n    dataPoints[x] = {\r\n      x: Math.random() * CANVAS_SIZE,\r\n      y: Math.random() * CANVAS_SIZE,\r\n      bias: 1\r\n    };\r\n  }\r\n\r\n  return dataPoints;\r\n};\r\n\r\nexport const labelData = dataPoints => {\r\n  let labeledData = dataPoints.map(data => {\r\n    return data.x > data.y ? { ...data, label: 1 } : { ...data, label: -1 };\r\n  });\r\n\r\n  return labeledData;\r\n};\r\n\r\nexport const weightData = dataPoints => {\r\n  let weightedData = dataPoints.map(data => {\r\n    return {\r\n      ...data,\r\n      weight: Math.random() * 2 - 1,\r\n      bias_weight: Math.random() * 2 - 1\r\n    };\r\n  });\r\n\r\n  return weightedData;\r\n};\r\n\r\nexport const guessData = dataPoints => {\r\n  let guessData = dataPoints.map(data => {\r\n    let weightedSum =\r\n      data.x * data.weight +\r\n      data.y * data.weight +\r\n      data.bias_weight * data.bias;\r\n    return { ...data, guess: Math.sign(weightedSum) };\r\n  });\r\n\r\n  return guessData;\r\n};\r\n\r\nexport const trainedData = (dataPoints, learningRate) => {\r\n  let trainData = dataPoints.map(data => {\r\n    let error = data.label - data.guess;\r\n    let newWeight = 0;\r\n    let deltaWeight = 0;\r\n    let newBiasWeight = 0;\r\n    if (error !== 0) {\r\n      newWeight = data.weight + error * data.x * data.y * learningRate;\r\n      newBiasWeight = data.bias_weight + data.bias * error * learningRate;\r\n      deltaWeight = newWeight - data.weight;\r\n    } else {\r\n      newWeight = data.weight;\r\n      newBiasWeight = data.bias_weight;\r\n      deltaWeight = 0;\r\n    }\r\n    return {\r\n      ...data,\r\n      weight: newWeight,\r\n      deltaWeight: deltaWeight,\r\n      bias_weight: newBiasWeight\r\n    };\r\n  });\r\n\r\n  return trainData;\r\n};\r\n\r\nexport const meanSquareError = dataPoints => {\r\n  let meanSquareError = 0;\r\n  dataPoints.map(data => {\r\n    let error = data.label - data.guess;\r\n    return (meanSquareError += Math.pow(error, 2));\r\n  });\r\n\r\n  return meanSquareError;\r\n};\r\n","import React, { Component } from \"react\";\nimport \"./App.css\";\n\nimport * as ml from \"./ml.js\";\n\nconst CANVAS_SIZE = 600;\n/*Below are some config options to play around with */\nconst CIRCLE_SIZE = 5;\nconst LEARNING_RATE = 0.00001;\nconst ITERATIONS = 30;\nconst TIMEOUT_BETWEEN_ITERATIONS = 1000;\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      labeledData: [],\n      guessData: [],\n      iteration: 0,\n      mse: 0\n    };\n  }\n\n  drawKnownData = data => {\n    return data.map((data, index) => {\n      if (data.label === 1) {\n        return (\n          <circle\n            key={index}\n            cx={data.x}\n            cy={data.y}\n            r={CIRCLE_SIZE}\n            fill=\"blue\"\n          />\n        );\n      } else {\n        return (\n          <circle\n            key={index}\n            cx={data.x}\n            cy={data.y}\n            r={CIRCLE_SIZE}\n            fill=\"red\"\n          />\n        );\n      }\n    });\n  };\n\n  drawGuessData = data => {\n    return data.map((data, index) => {\n      if (data.guess === 1) {\n        return (\n          <circle\n            key={index}\n            cx={data.x}\n            cy={data.y}\n            r={CIRCLE_SIZE}\n            fill=\"blue\"\n          />\n        );\n      } else {\n        return (\n          <circle\n            key={index}\n            cx={data.x}\n            cy={data.y}\n            r={CIRCLE_SIZE}\n            fill=\"red\"\n          />\n        );\n      }\n    });\n  };\n\n  startTraining = () => {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        let trainedData = ml.trainedData(this.state.guessData, LEARNING_RATE); //Params are Data, Learning Rate\n        let newTrainedData = ml.guessData(trainedData);\n        this.setState({ guessData: newTrainedData });\n        let meanSquaredError = ml.meanSquareError(this.state.guessData);\n        this.setState({ mse: meanSquaredError });\n        resolve();\n      }, TIMEOUT_BETWEEN_ITERATIONS);\n    });\n  };\n\n  componentDidMount = () => {\n    //We start off by creating a dataset with Labels we \"know\" are correct\n    let genData = ml.genData();\n    let labeledData = ml.labelData(genData);\n    this.setState({ labeledData: labeledData }); //This is our graph/chart on the left\n    //Below is the same Data but the Machine Guessing Weights for the Data\n    let weightedData = ml.weightData(labeledData);\n    //The machine now has random weights and will \"Guess\" the label of the data\n    let guessData = ml.guessData(weightedData);\n    this.setState({ guessData: guessData });\n    //Below Timeout is just so we could see the Data for 5 Seconds prior to any training happening\n    setTimeout(async () => {\n      for (let x = 0; x < ITERATIONS; x++) {\n        this.setState({ iteration: x + 1 });\n        await this.startTraining(this.state.guessData);\n      }\n    }, 5000);\n  };\n\n  render() {\n    return (\n      <div className=\"container\">\n        <div className=\"row\">\n          <svg\n            className=\"container-item\"\n            width={CANVAS_SIZE}\n            height={CANVAS_SIZE}\n          >\n            <rect\n              width={CANVAS_SIZE}\n              height={CANVAS_SIZE}\n              fill=\"green\"\n              fillOpacity=\"0.1\"\n            />\n            {this.drawKnownData(this.state.labeledData)}\n            <line\n              x1=\"0\"\n              x2={CANVAS_SIZE}\n              y1=\"0\"\n              y2={CANVAS_SIZE}\n              stroke=\"green\"\n            />\n          </svg>\n\n          <svg\n            className=\"container-item\"\n            width={CANVAS_SIZE}\n            height={CANVAS_SIZE}\n          >\n            <rect\n              width={CANVAS_SIZE}\n              height={CANVAS_SIZE}\n              fill=\"yellow\"\n              fillOpacity=\"0.1\"\n            />\n            {this.drawGuessData(this.state.guessData)}\n            <line\n              x1=\"0\"\n              x2={CANVAS_SIZE}\n              y1=\"0\"\n              y2={CANVAS_SIZE}\n              stroke=\"green\"\n            />\n          </svg>\n          <div>\n            <p>\n              The left SVG shows our trained data set. The right SVG shows our\n              data set being trained.\n            </p>\n            <p>\n              Perceptron Training Iteration: <b>{this.state.iteration}</b>\n            </p>\n            <p>\n              Maximum Iterations capped at <b>{ITERATIONS}</b>. Learning Rate is{\" \"}\n              <b>{LEARNING_RATE}</b>. Timeout between Iterations:{\" \"}\n              <b>{TIMEOUT_BETWEEN_ITERATIONS}ms</b>\n            </p>\n            <p>\n              Mean Squared Error: <b>{this.state.mse}</b>\n            </p>\n            <p>\n              Refresh the page to generate new points and re-test the Perceptron\n            </p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}